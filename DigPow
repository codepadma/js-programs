/ * Some numbers have funny properties. For example:

* 89 --> 8¹ + 9² = 89 * 1

* 695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2

* 46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
* Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n. In other words:

* Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k
* If it is the case we will return k, if not return -1.

* Note: n, p will always be given as strictly positive integers.

* digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
* digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
* digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
* digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
* /


// input - number n, and a number p (power)
// ouput - positive integer k.
// Eg: 695, 2 -> 6 ^ 2 + 9 ^ 3 + 5 ^ 4 = sum ==> 695 * k  
// process - Split the number into digits, traverse through the digits and find the sum of the powers of the digits.
// find k: number / sum and return k

function digPow(num, pow) {
  // split the number into digits.
  // Traverse through the digits. For each digit, find Math.pow(digit, pow) and add it to the sum. Increase pow by 1 for next digit.
  var sum = num.toString().split('').reduce(function(sum, digit) {
    return sum + Math.pow(parseInt(digit), pow++);
  }, 0);
  return (sum % num === 0) ? sum / num : -1;
}

digPow(695, 2);
